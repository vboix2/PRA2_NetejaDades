---
lang: ca-ES
title: "Pràctica 2: Neteja i validació de dades"
subtitle: "Tipologia i cicle de vida de les dades"
author: "Jesús Marí i Víctor Boix"
date: "Data de presentació: 11/06/2019"
output: 
  pdf_document:
    toc: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r include=FALSE}
# Càrrega de paquets
library(colorspace)
library(grid)
library(data.table)
library(VIM)
library(ggplot2)
library(plyr)
library(gmodels)
library(nortest)
library(corrplot)
library(caret)
library(ROCR)
library(pROC)
library(ggforce)
library(magrittr)
```

------

# 1. Descripció del dataset

El dataset utilitzat en aquesta pràctica s'ha obtingut de la pàgina web de *Kaggle*  (https://www.kaggle.com/c/titanic) i conté les dades dels passatgers del Titanic durant el desastre del 1912. L'objectiu d'aquest conjunt de dades és realitzar una predicció sobre la supervivència d'alguns passatgers a partir de les seves característiques. Per tant, es tracta d'un problema de classificació d'aprenentatge supervisat, on cal construir un model capaç de determinar el valor de l'atribut *Survived* (variable objectiu o dependent) a partir de la resta d'atributs (variables independents). 

Les conjunt de dades està format per dos fitxers CSV:

* *Titanic_train.csv*. Conjunt d'entrenament que servirà per entrenar el model, per tant, conté l'atribut objectiu o classe *Survived*. Està format per 891 registres i 12 atributs.
* *Titanic_test.csv*. Conjunt de prova, conté els registres sobre els que cal realitzar la predicció. Està format per 418 registres i 11 atributs.

La informació que contenen els atributs és la següent:

* *PassengerId*. Identificador únic del viatger al dataset (nombre enter).
* *Survived*. Atribut que indica si el passatger va sobreviure a la catàstrofe (1: va sobreviure, 0: va morir). Només disponible al conjunt *train*.
* *Pclass*. Indica la classe en què viatjava el passatger (1: primera classe, 2: segona classe, 3: tercera classe).
* *Name*. Nom complet del viatger (cadena de text).
* *Sex*. Sexe del viatger (male: home, female: dona).
* *Age*. Edat del viatger en anys (nombre real).
* *SibSp*. Nombre de germans, germanes o marit/muller a bord del vaixell (nombre enter).
* *Parch*. Nombre de pares o fills a bord del vaixell (nombre enter).
* *Ticket*. Nombre del tiquet (cadena de text).
* *Fare*. Import pagat pel bitllet (nombre real).
* *Cabin*. Cabina on s'allotjava el passatger (cadena de text).
* *Embarked*. Port d'embarcament del viatger (C: Cherbourg, Q: Queenstown, S: Southampton).

# 2. Integració i selecció de les dades

Per tal de realitzar els processos de neteja i anàlisi de les dades carregarem els dos fitxers en
dos dataframes que anomenarem *train* i *test*. Totes les operacions de neteja les realitzarem sobre els dos dataframes.

```{r}
# Càrrega dels fitxers de dades
train <- read.csv('../data/Titanic_train.csv')
test <- read.csv('../data/Titanic_test.csv')
```

L'atribut *PassengerId* és un identificador numèric dels registres del dataframe que no ens aporta cap informació sobre els passatgers, per tant, l'eliminarem, ja que per identificar els registres ja disposem de l'índex.

```{r}
# Eliminem l'atribut PassengerId a train i test
train <- train[,-1]
test <- test[,-1]
```

La resta d'atributs els mantindrem perquè ens donen informació sobre el viatger i poden resultar útils per al model. Podem fer una visualització dels primers registres amb la funció *head()*.

```{r}
# Primers registres del dataframe train
head(train, 3)
```

# 3. Neteja de les dades

Comencem examinant el dataframe amb la funció *str()*, que ens mostra el tipus de dada i els valors dels primers registres per a cada atribut.

```{r}
# Examinem el conjunt train
str(train)
```

```{r}
# Examinem el conjunt test
str(test)
```

L'atribut *Name* és de tipus factor, però té tant nivells com registres, per tant el convertirem a *character*.

```{r}
# Conversió de Name a character
train[,'Name'] <- as.character(train[,'Name'])
test[,'Name'] <- as.character(test[,'Name'])
```

La variable *Survived* és l'atribut classe i, per tant, és de tipus categòric. En aquest cas farem la conversió a factor.

```{r}
# Conversió de Survived a factor
train[,"Survived"] <- as.factor(train[,"Survived"])
```

Els tipus de dada per a cada atribut són:

* *Factor*: Sex, Ticket, Cabin, Embarked, Survived
* *int*: Pclass, SibSp, Parch
* *num*: Age, Fare
* *chr*: Name

Abans d'analitzar els elements buit i extrems pot resultar útil mostrar un resum de les dades amb la funció *summary()*.

```{r}
# Resum de les dades train
summary(rbind(train[-1],test))
```


## 3.1. Elements buits

Per començar examinem els elements buits a les columnes dels dos conjunts de dades. Podem veure que tenim molts valors NA a la columna *Age* dels dos dataframes i un a la columna *Fare* del conjunt de test. 

```{r}
# Nombre de valors NA per atribut
sapply(train, function(x) sum(is.na(x)))
sapply(test, function(x) sum(is.na(x)))
```

A més, els atributs *Cabin* i *Embarked* també contenen valors buits.

```{r}
# Nombre de valors buits per atribut
sapply(train, function(x) nrow(train[x=='',]))
sapply(test, function(x) nrow(test[x=='',]))
```

A continuació analitzarem els atributs que contenen valors NA o buit i els hi assignarem valors utilitzant diferents tècniques.

**Fare**

Per imputar el valor buit del preu del bitllet (*Fare*) podem utilitzar la informació de la classe del viatger (*Pclass*), ja que és lògic pensar que els bitllets de millor classe seran més cars. Això ho podem confirmar mostrant la mitjana de *Fare* per a cada valor de *Pclass*.

```{r}
# Mitjana de Fare per cada valor de Pclass als conjunts train i test conjuntament
aggregate(Fare~Pclass, data=rbind(train[,-1],test), mean)
```

Com veiem, hi ha una diferència significativa entre la mitjana del preu de bitllet per a cada classe. Utilitzarem aquesta circumstància per imputar el valor NA de *Fare* amb la mitjana de valors per als viatgers de la mateixa classe.

```{r}
# Imputem el valor NA de Fare amb la mitjana de valors de la mateixa classe
test[is.na(test$Fare),'Fare'] <- aggregate(Fare~Pclass, data=rbind(train[,-1],test),
                                           mean)[test[is.na(test$Fare),'Pclass'],'Fare']
```

**Cabin**

En el cas de l'atribut *Cabin*, substituirem els valors buits pel marcador 'NO'.

```{r}
levels(train$Cabin)[levels(train$Cabin)==''] <- 'NO'
levels(test$Cabin)[levels(test$Cabin)==''] <- 'NO'
```

**Embarked**

Per imputar els valors buits del port d'embarcament (*Embarked*) podem aprofitar la informació del bitllet. Si consultem les dades dels viatgers que tenen un valor buit a *Embarked* veiem que tenen el mateix número de bitllet.

```{r}
# Ticket dels viatgers amb valor buit a Embarked
train[train$Embarked=='',c("Embarked", "Ticket")]
```

Si ampliem la cerca i mostrem el valor d'*Embarked* per a tots els viatgers amb un número de bitllet semblant (113XXX) veiem que la majoria han pujat a Southampton ('S').

```{r}
# Viatgers amb un número de ticket semblant a l'anterior (113XXX) agrupats pel valor d'Embarked
 summary(train[grep("113.*",train$Ticket),"Embarked"])

# Assignem el valor 'S' als valors buits d'Embarked
levels(train$Embarked) <- c("S", "C", "Q", "S")
```

Per tant assignarem aquest valor als dos valors buits d'*Embarked*.

```{r}
# Assignem el valor 'S' als valors buits d'Embarked
levels(train$Embarked) <- c("S", "C", "Q", "S")
```

**Age**

Finalment, per imputar el valor buit de l'edat (*Age*) farem servir el mètode basat en els k-veïns més propers (KNN). El que fa l'algorisme knn-imputation és identificar les k-observacions més properes i assignar la mitjana ponderada a l'atribut amb valor NA. En el nostre cas utilitzarem k=3 i tindrem en compte tots els atributs excepte *Name*.

```{r}
# Imputació de valors amb VIM
train$Age <- kNN(train[,-3], k=3)$Age 
test$Age <- kNN(test[,-2], k=3)$Age 
```

Per acabar, comprovem que ja no hi ha cap valor NA o buit.

```{r}
# Nombre de valors NA per atribut
sapply(train, function(x) sum(is.na(x)))
sapply(test, function(x) sum(is.na(x)))

# Nombre de valors buits per atribut
sapply(train, function(x) nrow(train[x=='',]))
sapply(test, function(x) nrow(test[x=='',]))
```

## 3.2. Valors extrems

Els valors extrems o *outliers* són aquells valors que es troben tan allunyats de la resta de valors que ens poden fer pensar que són erronis o tenen un origen diferent. Generalment es consideren *outliers* els valors que estan a més de 3 desviacions estàndards de la mitjana de la població. A continuació estudiarem els valors extrems per als atributs de tipus numèric, tant enters com reals.

**Age**

Si representem el diagrama de caixa de l'atribut *Age* veiem que la majoria de passatgers se situen entre els 20 i els 40 anys, però també apareixen alguns punts aïllats per sobre dels 60 anys.

```{r}
# Diagrama de caixa de l'atribut Age
A.Age <- c(train$Age,test$Age)
boxplot(A.Age, horizontal = TRUE)
```

Si mostrem els valors extrems per a aquest atribut obtenim molts valors entre 60 i 80.

```{r}
# Possibles outliers a l'atribut Age
boxplot.stats(A.Age)$out
```

Si calculem els valors que es troben per sobre de 3 desviacions estàndard el nombre d'*outliers* disminueix a només 3.

```{r}
# Edats superiors a 3 desviacions estàndard per sobre de la mitjana
A.Age[A.Age > (mean(A.Age) + 3 * sd(A.Age))]

# Rang total de l'atribut Age
range(A.Age)
```

Tot i que hem detectat 3 possibles outliers, tots els passatgers se situen entre els 0 i els 80 anys, que són edats perfectament possibles i per tant mantindrem tots els registres sense cap modificació.


**SibSp**

L'atribut *SibSp* ens indica el nombre de germans o marit/muller de cada passatger. Si mostrem la distribució de valors en una diagrama de caixa veiem que la majoria de valors se situen entre 0 i 1.

```{r}
# Diagrama de caixa de l'atribut SibSp
A.SibSp <- c(train$SibSp, test$SibSp)
boxplot(A.SibSp, horizontal = TRUE)
```

Repetint les anàlisis anteriors veiem que la funció *boxplot* detecta com a extrems els valors superiors a 2, si calculem els valors superiors a 3 desviacions estàndard trobem els valors superiors a 3, mentre que el valor més alt de l'atribut és de 8. Tots aquests valors són perfectament possibles com a nombre de fills i per tant també els mantidrem.

```{r}
# Possibles outliers a l'atribut SibSp
boxplot.stats(A.SibSp)$out

# Valors per sobre de 3 SD
A.SibSp[A.SibSp > (mean(A.SibSp) + 3 * sd(A.SibSp))]

# Rang total de l'atribut
range(A.SibSp)
```

**Parch**

L'atribut *Parch* indica el nombre de pares o fills al vaixell per a cada passatger. Si repetim els càlculs obtenim un resultat molt semblant a l'anterior. En aquest cas, la majoria de registres tenen un valor de 0, això fa que la mitjana sigui molt baixa i la resta de valors apareguin com a outliers. Malgrat tot, els rang de l'atribut se situa entre 0 i 9 fills, que són valors possibles i que encaixen amb els resultats de *SibSp*, per tant també els mantindrem.

```{r}
# Diagrama de caixa de l'atribut Parch
A.Parch <- c(train$Parch, test$Parch)
boxplot(A.Parch, horizontal = TRUE)
```

```{r}
# Possibles outliers a l'atribut Parch
boxplot.stats(A.Parch)$out

# Valors per sobre de 3 SD
A.Parch[A.Parch > (mean(A.Parch) + 3 * sd(A.Parch))]

# Rang total de l'atribut
range(A.Parch)
```

**Fare**

Per acabar estudiarem els valors extrem de l'atribut *Fare*, que indica el preu del bitllet de cada passatger. En aquest cas veiem que la majoria de bitllets se situen per sota de 50, tenim molts possibles *outliers* per sobre de 80 i un valor màxim superior als 500.

```{r}
# Diagrama de caixa de l'atribut Fare
A.Fare <- c(train$Fare, test$Fare)
boxplot(A.Fare, horizontal = TRUE)
```

```{r}
# Possibles outliers a l'atribut Fare
boxplot.stats(A.Fare)$out

# Valors per sobre de 3 SD
A.Fare[A.Fare > (mean(A.Fare) + 3 * sd(A.Fare))]

# Rang total de l'atribut
range(A.Fare)
```

Com en els casos anteriors, per a aquest atribut també hem decidit mantenir tots els valors.


## 3.3. Conversió de dades

A continuació transformarem alguns atributs per tal de reduir-ne el nombre de categories o obtenir-ne informació que pugui resultat interessant per a la fase d'anàlisi.

**Name**

A l'atribut *Name* n'extraurem el títol de tractament, ja que indica l'estatus del viatger i pot influir en la seva supervivencia.

```{r}
# Extraiem el títol de l'atribut Name
train$Title <- sub(".*\\s([A-Za-z]+)\\..*", "\\1", train$Name)
test$Title <- sub(".*\\s([A-Za-z]+)\\..*", "\\1", test$Name)

# Nombre de registres per categoria de Title
table(c(train$Title, test$Title))
```

A continuació, com que el nombre de categories és força gran i algunes tenen molt pocs registres, unirem els títols poc freqüents ens una mateixa categoria 'other'. Per acabar, convertim l'atribut a tipus factor.

```{r}
# Marquem com a 'other' els títols menys freqüents
others <- c("Capt","Countess","Don","Dona","Jonkheer","L","Lady","Mme","Sir",
            "Major","Mlle","Ms","Col","Dr","Rev")
train[train$Title %in% others, 'Title'] = 'other'
test[test$Title %in% others, 'Title'] = 'other'

# Convertim Title a factor
train$Title <- as.factor(train$Title)
test$Title <- as.factor(test$Title)
```

**Cabin**

L'atribut cabina conté més de 100 nivells. Una manera de reduir-los pot ser eliminar els números i conservar únicament la lletra, ja que segurament indica el tipus de cabina o la zona on s'allotjaven els passatgers i pot resultar significativa.

```{r}
# Extraiem la lletra de l'atribut Cabin
levels(train$Cabin)[-1] <- sub("([A-T]).*","\\1", levels(train$Cabin)[-1])
levels(test$Cabin)[-1] <- sub("([A-T]).*","\\1", levels(test$Cabin)[-1])

# Freqüència de supervivents per cabina
table(train[,c("Survived","Cabin")])
```

Com veiem, les cabines A, F, G i T tenen molt pocs passatgers i un percentatge de supervivents força semblant. Per evitar tenir cabines amb pocs registres i millorar l'eficàcia de les anàlisis unirem aquestes cabines en una mateixa categoria que anomenarem X.

```{r}
# Reanomenem a X les cabines A, F, G i T
levels(train$Cabin) <- c("NO", "X", "B", "C", "D", "E", "X", "X", "X")
levels(test$Cabin) <- c("NO", "X", "B", "C", "D", "E", "X", "X", "X")
```

**Ticket**

Finalment, tot i que l'atribut *Ticket* també conté molts nivells i sembla poc útil, podem provar d'extreure'n alguna informació interessant. A continuació mostrem les dades d'alguns passatgers que comparteixen el valor de *Ticket*.

```{r}
# Valors més freqüents de Ticket
sort(table(train$Ticket), decreasing = TRUE)[c(1:5)]

# Passatgers amb el Ticket més freqüent
train[train$Ticket=='1601',]
```

Com veiem, els passatgers amb un mateix valor per a *Ticket* també comparteixen moltes característiques, perquè segurament formaven una família o viatjaven junts. Això ho aprofitarem per calcular la mida del grup de persones que viatjaven conjuntament i crear l'atribut *Group*.

```{r}
# Creem una taula de freqüències per als tickets
tickets <- as.data.frame(table(rbind(train["Ticket"],test["Ticket"])))
colnames(tickets) <- c("Ticket","Group")

# Assignem el valor de la freqüència a un nou atribut "Group"
train <- join(train, tickets, by="Ticket")
test <- join(test, tickets, by="Ticket")
```

**Fare**

Finalment, com que el preu del bitllet sembla ser el mateix per a cada ticket, és a dir, sembla tractar-se de l'import per a tot el grup, dividirem l'import del passatge (*Fare*) per les dimensions del grup (*Group*) per tal d'obtenir el preu individual del bitllet.

```{r}
# Càlcul del preu individual del bitllet
train$Fare <- train$Fare / train$Group 
test$Fare <- test$Fare / test$Group
```

Per acabar, eliminem els atributs *Name* i *Ticket* per evitar la redundància de dades, ja que els hem utilitzat per generar els atributs derivats *Title* i *Group*.

```{r}
# Eliminem l'atribut Name i Ticket
train <- train[,-c(3,8)]
test <- test[,-c(2,7)]
```


## 3.4. Exportació de dades

Una vegada hem netejat les dades les exportarem en un nou fitxer.

```{r}
# Exportació dels conjunt train i test nets
write.csv(train, '../data/Titanic_train_clean.csv', row.names = FALSE)
write.csv(test, '../data/Titanic_test_clean.csv', row.names = FALSE)
```

# 4. Anàlisi de dades

## 4.1. Selecció de dades

La fase d'anàlisi s'enfocarà en estudiar les dades des de diferents punts de vista i intentant respondre diferents preguntes:

1. Com és la distribució de valors per a les variables numèriques contínues? La mitjana de valors és significativament diferent per als supervivents i no supervivents?
2. Hi ha correlacions entre variables numèriques que permetin prescindir d'algun atribut?
3. La probabilitat de sobreviure és significativament diferent entre les diferents categories?
4. Quina és la probabilitat de sobreviure per als passatgers del conjunt de test?

La primera pregunta estudia la distribució de les variables numèriques contínues (*Age* i *Fare*). Començarem estudiant si els seus valors segueixen una distribució normal, a continuació compararem la variància en funció del valors de la classe (*Survived*) i, finalment, aprofitarem aquest resultat per comparar la mitjana de valors en funció del valor de la classe (*Survived*). Això ens permetrà saber si la mitjana d'edat i del preu del bitllet són significativament diferents entre els supervivents i els no supervivents.

Per a respondre la segona pregunta estudiarem la correlació entre les variables quantitatives (*Pclass*, *Age*, *SibSp*, *Parch*, *Fare* i *Group*). En principi es tracta de les variables independents del conjunt de dades, per aquest motiu, si detectem alguna dependència important significarà que hi ha redundància en les dades i pot ser necessari eliminar alguna columna. Per fer aquesta anàlisi treballarem amb els dos conjunts de dades: *train* i *test*.

La tercera pregunta se centra en les variables qualitatives (*Sex*, *Cabin*, *Embarked* i *Title*) on avaluarem si hi ha diferències significatives en el percentatge de supervivents entre els diferents grups definits per aquestes variables. Per fer aquesta anàlisi utilitzarem el test de $\chi^2$ amb la funció *chisq.test*, també sobre les dades de *train*.

Finalment, la darrera pregunta és la més important perquè recull els resultats de les tres anteriors i planteja el problema principal de l'estudi: la creació d'un model predictiu per a la classe *Survived*. Treballarem amb el conjunt *train* per crear un model de regressió logística a partir de totes les variables, tant les numèriques com les categòriques, i l'utilitzarem per efectuar prediccions sobre el conjunt de *test*.

```{r}
# Variables numèriques
var_num <- c("Pclass","Age","SibSp","Parch","Fare","Group")

# Variables categòriques
var_cat <- c("Sex","Cabin","Embarked","Title")
```


## 4.2. Anàlisi de la distribució de variables contínues

Per fer les anàlisis de normalitat i homogeneïtat de la variància ens centrarem en els atributs de tipus *numeric*, que són *Age* i *Fare*. En primer lloc unirem els dos conjunts de dades en un mateix dataframe per facilitar-ne l'estudi.

```{r}
# Unim les dades en un dataframe
test_and_train <- rbind(train[c("Age","Fare")],test[c("Age","Fare")])
```

### 4.2.1 Normalitat

**Age**

Començarem analitzant la normalitat de la distribució de l'atribut *Age* de manera gràfica, representant les dades en un histograma i utilitzant la gràfica Q-Q.

```{r}
# Representem les dades en un histograma
ggplot(data = test_and_train, aes(x = Age)) +
  geom_histogram(aes(y = ..density.., fill = ..count..), binwidth = 3) +
  scale_fill_gradient(low = "#DCDCDC", high = "#7C7C7C") +
  stat_function(fun = dnorm, colour = "firebrick",
                args = list(mean = mean(test_and_train$Age),
                            sd = sd(test_and_train$Age))) +
  ggtitle("Histograma + curva normal") +
  theme_bw()
```

Tot i que la majoria de franges d'edat s'acosten a una distribució normal, l'interval aproximat entre 18 i 25 anys és molt més freqüent que la resta i s'allunya molt d'aquesta distribució. Com veiem a continuació, la gràfica Q-Q segueix la línia de normalitat a la regió central però s'allunya als extrems.

```{r}
# Representació de la gràfica Q-Q d'Age
qqnorm(test_and_train$Age, pch = 19, col = "gray50")
qqline(test_and_train$Age)
```

Per tal d'avaluar la normalitat de la distribució de manera numèrica utilitzarem el contrast d'hipòtesis. En primer lloc farem el test de Shapiro-Wilk. 

```{r}
# Test de normalitat de Shapiro-Wilk
shapiro.test(test_and_train$Age)
```

Prenent com a hipòtesi nul·la que la distribució de valors d'*Age* és normal i fixant un nivell de significació del 5%, veiem com el càlcul del p-valor és molt inferior al nivell de significació i ens veiem obligats a rebutjar la hipòtesi nul·la; és a dir, no podem afirmar que la distribució d'*Age* sigui normal.

Com que es tracta d'una mostra relativament gran (|T| > 50), verificarem els resultats amb el test d'Anderson-Darling.

```{r}
# Test de normalitat d'Anderson-Darling
ad.test(test_and_train$Age)
```

Els resultats també ens diuen que no podem considerar que la distribució d'edats segueixi una corba normal.

**Fare**

A continuació repetim les gràfiques i els càlculs per avaluar la normalitat de l'atribut *Fare*.

```{r}
# Representem les dades en un histograma
ggplot(data = test_and_train, aes(x = Fare)) +
  geom_histogram(aes(y = ..density.., fill = ..count..), binwidth = 3) +
  scale_fill_gradient(low = "#DCDCDC", high = "#7C7C7C") +
  stat_function(fun = dnorm, colour = "firebrick",
                args = list(mean = mean(test_and_train$Fare),
                            sd = sd(test_and_train$Fare))) +
  ggtitle("Histograma + curva normal") +
  theme_bw()
```


```{r}
# Representació de la gràfica Q-Q per a Fare
qqnorm(test_and_train$Fare, pch = 19, col = "gray50")
qqline(test_and_train$Fare)
```

A nivell gràfic, els valors de *Fare* tampoc semblen seguir una distribució normal. Això ho confirmem amb els tests de Shapiro-Wilk i d'Anderson-Darling.

```{r}
# Test de normalitat de Shapiro-Wilk
shapiro.test(test_and_train$Fare)
```

```{r}
# Test de normalitat d'Anderson-Darling
ad.test(test_and_train$Fare)
```

En tots dos casos el càlcul del p-valor resulta molt inferior al nivell de significació i, per tant, no podem afirmar que els valors de l'atribut *Fare* segueixin una distribució normal.

### 4.2.2. Homoscedasticitat

A continuació estudiarem si la variància de les variables numèriques *Age* i *Fare* és constant als grups de les persones que sobreviuen respecte a les que no ho fan. Com que cap de les dues de les variables té una distribució normal utiltizarem el test Fligner-Killeen. En aquest test la hipòtesi nul·la contempla que les variàncies entre els grups són iguals.

**Age**

```{r}
# Apliquem el test Fligner-Killeen a Age respecte als valors de Survived
fligner.test(Age ~ Survived, data=train)
```

Com el p-valor resultat és més gran que 0.05 no hi ha una justificació per rebutjar la hipòtesi nul·la. Això ens indica que la variància de l'edat és similar en ambdós grups.

**Fare**

```{r}
# Apliquem el test Fligner-Killeen a Fare respecte als valors de Survived
fligner.test(Fare ~ Survived, data=train)
```

Com el p-valor resultant és pràcticament 0, podem rebutjar la hipòtesi nul·la. Això ens indica que la variància de la variable *Fare* és significativament diferent en ambdós grups. Aquest resultat el podem comprovar gràficament mostrant la distribució de valors per a les dues classes en un diagrama de caixa.

```{r}
# Diagrama de caixa de Fare per a les classes de Survived
ggplot(data = train, aes(x = Survived, y = Fare, colour = train$Survived)) +
  geom_boxplot() +
  geom_point() +
  theme_bw() +
  theme(legend.position = "none")
```

### 4.2.3. Comparació de les mitjanes d'*Age* i *Fare*

Les variables *Age* i *Fare* presenten una important desviació respecte de la normal, per tant, emprarem el test no paramètric de Kruskal-Wallis per analitzar la diferència de les seves mitjanes.
En aquest test la hipòtesi nul·la contempla que les distribucions entre els grups són iguals.

```{r}
# Test de Kruskal-Wallis aplicat a Age respecte Survived
kruskal.test(Age  ~ Survived, data = train ) 

# Test de Kruskal-Wallis aplicat a Fare respecte Survived
kruskal.test(Fare  ~ Survived, data = train ) 
```

Com podem veure, el test de Kruskal-Wallis per a l'atribut *Age* ens dóna un p-valor superior a 0.05, per tant, no podem rebutjar la hipòtesi nul·la i hem de considerar que les dues mostres provenen de la mateixa distribució, és a dir, que la mitjana d'edat per a supervivents i no supervivents és la mateixa. A partir d'aquests resultats, ens plantejarem la possibilitat d'excloure aquest atribut del model.

D'altra banda, l'atribut *Fare* ens mostra un p-valor molt petit, això vol dir que podem afirmar que existeix una diferència significativa entre la mitjana del preu del bitllet per a les dues mostres.

## 4.3. Anàlisi de correlació

En aquest apartat ens preguntem si hi ha correlacions entre variables numèriques que permetin prescindir d'algun atribut. Per analitzar les possibles dependències generarem una matriu de correlacions entre totes les variables quantitatives dels conjunts de dades *train* i *test* conjuntament; a més, utilitzarem la correlació de *Spearman*, que no suposa cap tipus de distribució entre les dades, perquè com hem vist hi ha variables numèriques que no segueixen una distribució normal.

```{r}
# Correlació entre variables numèriques
corr <- cor(rbind(train[var_num], test[var_num]), method="spearman")
corr
```

```{r}
# Representació gràfica de la matriu de correlacions
corrplot(corr, method="circle")
```

Com era d'esperar, hi ha una forta correlació entre els atributs *Fare* i *Pclass*; el coeficient de *Spearman* és de -0.83, força proper a -1, que vol dir que per a classes més altes (valors més petits) augmenta el preu del bitllet i a l'inversa. A més, també s'aprecia una correlació positiva entre *Group-Parch* (0.64) i *Group-SibSp* (0.61) perquè tots aquests atributs informen de la mida de la família o grup de gent que viatjava conjuntament. Altres correlacions menys importants són *Age-Pclass* (-0,41), classes més altes (valors petits de Pclass) tenen edats més grans, i *SibSp-Parch* (0.43). 

A partir d'aquests resultats ens plantejarem la possibilitat d'excloure atributs redundants en el nostre model, com *Pclass* o *Fare*, en funció del nivell de significació que tinguin.

## 4.4. Contrast d'hipòtesis

A la tercera pregunta ens qüestionem si les diferents categories de les variables qualitatives (*Sex*, *Cabin*, *Embarked* i *Title*) influeixen en la probabilitat de sobreviure. Atès que la variable *Survived* també és qualitativa, emprarem el test $\chi^2$ amb la hipotesi nul·la que diu que les variables examinades no són independents. Primer calcularem les freqüències de *Survived* per a cada categoria i després aplicarem la funció *chisq.test*.

```{r}
# Test chi quadrat per a totes les variables qualitatives
for (var in var_cat){
  # Creem una taula de freqüències
  taula = table(train[, c("Survived", var)])
  print(taula)
  # Apliquem el test
  print(chisq.test(taula))
}
```

A L'execució podem veure com el p-valor és inferior al 0.05 en tots els casos, per tant, rebutgem la hipòtesi nul·la. Això vol dir que podem afirmar que hi ha diferències significatives entre el nombre de supervivents per a les diferents categories de *Sex*, *Cabin*, *Embarked* i *Title*. Aquestes diferències es poden apreciar gràficament si mostrem un diagrama de barres per a cada categoria.

```{r}
# Representació dels supervivents i no supervivents per categories
par(mfrow=c(2,2))
for (var in var_cat){
  barplot(table(train[,c("Survived", var)]), main = var, col = c("cadetblue4","aquamarine"))
}
legend("topleft", legend=c("No sobreviu","Sobreviu"), fill = c("cadetblue4","aquamarine"))
```

## 4.5. Regressió logística

Finalment, calcularem la probabilitat de supervivència per als passatgers del conjunt *test*. En el nostre cas, com que la variable a predir (dependent) és dicotòmica, utilitzarem una regressió logística.

### 4.5.1. Creació del model

Per generar el model de regressió logística utilitzarem la funció *regLog* amb totes les variables disponibles, tant les categòriques com les numèriques. Les variables numèriques no requereixen cap tipus de transformació, però les categòriques s'hauran de binaritzar, és a dir, haurem de crear un atribut de tipus binari per a cada categoria; malgrat tot, la funció *regLog* ja realitza aquesta transformació i per tant no serà necessari modificar cap atribut.

Per tal d'avaluar el model generat serà necessari dividir les dades de *train* en un conjunt d'entrenament i un altre de test. Malgrat tot, com que el nombre de dades no és gaire gran utilitzarem la validació creuada o *cross validaton* per poder generar un model a partir de totes les dades. En el nostre cas utilitzarem 4 particions (4-fold).

```{r}
# Creem les particions de la cross validation
folds <- trainControl(method = "cv", number=4)
# Entrenem el model
regLog <- train(Survived ~ Pclass + Age + SibSp + Parch + Fare + Group + Sex + Cabin + Embarked + Title,
               data = train, trControl = folds, method = "glm", family = binomial(link="logit"))
# Mostrem els coeficients
summary(regLog)
```

El model generat ens dóna una precisió de `r round(regLog$results[1,'Accuracy'], 3)`, que vol dir que més d'un 80% dels registres s'han classificat correctament.

Si analitzem els coeficients de la regressió i el p-valor calculat per a cada un, veiem que els atributs *Fare*, *Group*, *Sex* i *Embarked* resulten poc rellevants per a la regressió. Això s'explica perquè, sota la hipòtesi nul·la que el coeficient és 0, el seu p-valor és força gran i ens obliga a acceptar-la, que vol dir que podem prescindir d'aquests atributs. En canvi *Age*, a diferència del que ens mostrava el test de Kruskal-Wallis, sí que resulta important per al model. A partir d'aquests resultats tindrem en compte:

* **Fare**. A l'anàlisi de correlació hem vist que hi ha un lligam fort entre *Pclass* i *Fare*, per tant, resulta lògic mantenir *Pclass* a la regressió (molt més rellevant) i excloure *Fare*.
* **Group**. L'anàlisi de correlació també ens ha mostrat un lligam important de *Group* amb *SibSp* i *Parch*. Com que aquests dos també resulten rellevants per a la regressió optarem per excloure *Group*.
* **Sex**. Tot i que resulta sorprenent que *Sex* tingui tan poca importància, cal tenir en compte que segurament hi ha redundància de dades amb *TitleMr* i aquest atribut sí que resulta molt significatiu. Per tant, també exclourem *Sex* de la regressió.
* **Embarked**. La informació d'aquest atribut no la trobem en cap altre variable i el p-valor obtingut no és tant alt com a la resta d'atributs exclosos. En aquest cas optarem per mantenir aquesta variable perquè en el nou model pot ser que prengui més importància. 

A continuació crearem un nou model excloent les variables comentades.

```{r}
# Entrenem el model
regLog <- train(Survived ~ Pclass + Age + SibSp + Parch + Cabin + Embarked + Title,
               data = train, trControl = folds, method = "glm", family = binomial(link="logit"))
# Mostrem els coeficients
summary(regLog)
```

Com veiem, en aquest nou model hi ha més variables que resulten significatives i també millora la importància d'*Embarked*. Si calculem novament la precisió veiem que gairebé no ha variat.

```{r}
# Calculem la precisió del model
regLog$results['Accuracy']
```

### 4.5.2. Corba ROC

El model generat ens permet obtenir tant la probabilitat de sobreviure per a cada viatger com realitzar una predicció de *Survived*. A continuació calcularem la probabilitat de supervivència sobre el conjunt *train*, representarem la corba ROC i trobarem el llindar òptim per a determinar la supervivència de cada viatger.

```{r}
# Calculem la probabilitat de supervivència dels passatgers del conjunt train
prob_Survived <- predict(regLog, train, type="prob")['1']
colnames(prob_Survived) <- "prob_Survived"
# Unim les dades al conjunt train
y_train <- cbind(train, prob_Survived)
head(y_train,5)
```

Per a obtenir el llindar més adequat de probabilitat representarem la corba ROC.

```{r}
# Corba ROC del conjunt train
plot.roc(y_train$Survived, y_train$prob_Survived,  
         main="Confidence interval of a threshold",
         percent=TRUE,  ci=TRUE, of="thresholds",
         thresholds="best", 
         print.thres="best")
```

Els càlculs mostren que el llindar òptim per a la classe *Survived* és de 0.5; això vol dir que considerarem com a supervivents els passatgers que obtinguin una probabilitat superior a 0.5 segons el model. A partir d'aquest resultat podem fer una predicció del valor de *Survived* i mostrar la matriu de confusió.

```{r}
# Assignem com supervivents les probabilitats superiors al 50%
y_train$Survived_pred <- ifelse(y_train$prob_Survived>0.5, 1, 0)
# Convertim les prediccions atipus factor
y_train$Survived_pred <- as.factor(y_train$Survived_pred)
# Mostrem la matriu de confusió
gmodels::CrossTable(y_train$Survived, y_train$Survived_pred)
```

Com veiem, dels 891 registres del conjunt *train*, tenim:

* *Verdaders negatius*: 481 no supervivents s'han classificat correctament.
* *Falsos positius*: 68 no supervivents s'han classificat com a supervivients.
* *Falsos negatius*: 75 supervivents s'han classificat com a no supervivents.
* *Verdaders positius*: 267 supervivents s'han classificat correctament.


### 4.5.3. Predicció del conjunt test

A partir del model de regressió logística generat als apartats anteriors, podem fer una predicció de la probabilitat de supervivència del conjunt *test* amb la funció *predict*.

```{r}
# Calculem la probabilitat de supervivència dels passatgers del conjunt test
prob_Survived <- predict(regLog, test, type="prob")['1']
colnames(prob_Survived) <- "prob_Survived"

# Afegim la predicció al conjunt de dades
solution <- cbind(test, prob_Survived)
# Assignem com a supervivents els passatgers amb probabilitats superiors al 50%
solution$Survived_pred <- ifelse(solution$prob_Survived>0.5, 1,0)
# Convertim la predicció a tipus factor
solution$Survived_pred<-as.factor(solution$Survived_pred)

# Mostrem els resultats per als primers registres
head(solution,5)
```


# 5. Representació de dades

En els apartats anteriors hem anat complementant les diferents anàlisis amb gràfiques i taules que ens mostraven els resultats obtinguts. En aquest apartat ens centrarem en representar els resultats de les prediccions sobre el conjunt *test*.

**Gràfic de conjunts paral·lels**

Per tal de tenir una visió general de la solució al problema crearem un gràfic de conjunts paral·lels que mostri les variables enteres i categòriques que han resultat més significatives per al model (*Pclass*, *SibSp* i *Title*) juntament amb la classe *Survived*.

```{r}
# Generem un gràfic de conjunts paral·lels
solution_temp <-solution
names(solution_temp)[names(solution_temp) == "Title"] <- "F_Title"
names(solution_temp)[names(solution_temp) == "SibSp"] <- "C_SibSp"
names(solution_temp)[names(solution_temp) == "Pclass"] <- "D_Pclass"
names(solution_temp)[names(solution_temp) == "Survived_pred"] <- "G_Surv"

solution_temp$C_SibSp<- as.factor(solution_temp$C_SibSp)
solution_temp$D_Pclass<- as.factor(solution_temp$D_Pclass)

data <- reshape2::melt(solution_temp)
data <- gather_set_data(data, c("F_Title", "C_SibSp",  "D_Pclass", "G_Surv"))

ggplot(data, aes(x, id = id, split = y, value = value)) +
  geom_parallel_sets(aes(fill = G_Surv), alpha = 0.25, axis.width = 0.2,
                     n=100, strength = 0.5) +
  geom_parallel_sets_axes(axis.width = 0.25, fill = "gray95",
                          color = "gray80", size = 0.15) +
  geom_parallel_sets_labels(colour = 'black',angle = 0 ) +
  theme_minimal() +
  theme(
    legend.position = "none",
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.text.y = element_blank(),
    axis.text.x = element_text(size = 10, face = "bold"),
    axis.title.x  = element_blank()
    )
```

El diagrama mostra clarament que la majoria de no supervivents són homes adults (títol *Mr*), probablement perquè els primers a evacuar el vaixell foren dones i nens. A més, veiem com els pocs *Mr* supervivents són gairebé tots de primera classe. També podem observar com el percentatge de supervivents entre els passatgers de primera classe resulta superior a la resta.

**Piràmide segons Age**

A continuació estudiarem els resultats en funció del valor de la variable numèrica *Age*. Per fer-ho crearem una piràmide que agrupi els passatgers per edats, representant les persones que sobreviuen a l'esquerra del 0 i els que no ho fan a la dreta. A més, mostrarem en diferents colors la categoria *Title*.

```{r}
# Representació de la piràmide en funció d'Age
piramid_solution <- solution_temp[, c("Age","G_Surv","F_Title")]
piramid_solution$Age <- cut(piramid_solution$Age, seq(-0,100,by=10))
piramid_solution <- count(piramid_solution, c("Age","G_Surv","F_Title"))


ggplot(data = piramid_solution, aes(x = Age, y = freq, fill = F_Title)) +

  geom_bar(data = subset(piramid_solution, G_Surv == 0),
           stat = "identity",
           position = "identity") +
  geom_bar(data = subset(piramid_solution, G_Surv == 1) ,
           stat = "identity",
           position = "identity",
           mapping = aes(y = -freq)) +
        coord_flip() + 
  scale_y_continuous(labels = abs)
```

Al gràfic veiem clarament com l'interval d'edats (20,30] és el més nombrós i també com els homes adults (títol de Mr) són els que majoritàriament no sobreviuen. Destaquem un petit grup amb titol "Master" (es refereix als nens en anglés) de (0,10] anys en què sobreviuen aproximadament la meitat.

# 6. Resolució del problema

A la fase d'anàlisi ens hem plantejat quatre preguntes per tal d'estudiar les dades. Les tres primeres preguntes estaven enfocades a estudiar la distribució de valors i la seva possible importància per a la construcció del model, mentre que la darrera pregunta plantejava l'objectiu real del problema.

Tant la representació gràfica (histograma i gràfica Q-Q) com els test estadístics (Shapiro-Wilk i Anderson-Darling) ens han mostrat que les variables numèriques contínues (*Age* i *Fare*) no segueixen una distribució normal. D'altra banda, si separem les passatgers segons el valor de la classe *Survived*, tant la mitjana com la variància dels valors d'*Age* poden considerar-se d'una mateixa població i, per tant, iguals per als dos grups. En canvi, la mitjana i la variància de *Fare* sí que mostren diferencies significatives en funció del valor de *Survived*. Aquest resultat ens indica que *Fare* pot tenir més importància per construir el model predictiu.

Utilitzant el coeficient de correlació d'Spearman hem obtingut una correlació important entre *Pclass-Fare*, i dues correlacions notables entre *Group-SibSp* i *Group-Parch*. Això ens ha plantejat la possibilitat de prescindir d'alguns d'aquests atributs al model.

Per estudiar la importància de les variables categòriques en el valor de *Survived* hem utilitzat el test *chi quadrat* ($\chi^2$). Els resultats ens han mostrat que hi ha diferències significatives en el nombre de supervivents per a cada categoria; per tant, que les variables categòriques *Sex*, *Cabin*, *Embarked* i *Title* poden resultar importants per al model.

Finalment, hem construït un model de regressió logística capaç d'efectuar prediccions sobre el valor de la classe *Survived* a partir de tots els atributs. La informació d'aquest model i els resultats de les proves anteriors els hem utilitzat per prescindir d'atributs redundants o poc significatius per al model (*Fare*, *Group* i *Sex*). El model final l'hem construït amb la resta de variables (*Pclass*, *Age*, *SibSp*, *Parch*, *Cabin*, *Embarked* i *Title*), l'hem avaluat amb una validació creuada en 4 particions (4-fold) i ens ha donat una precisió superior al 80%. Aquest model l'hem utilitzat per calcular la probabilitat de sobreviure per als passatgers del conjunt *test* i efectuar una predicció per al valor de *Survived*.

Per acabar, podem avaluar els resultats obtinguts guardant les prediccions de *test* en un fitxer i enviant les dades a *Kaggle*. Si ho fem obtenim una precisió de 0.75598, que vol dir que hem classificat correctament més del 75% dels registres del conjunt *test*.

```{r}
# Creem un dataframe amb l'identificador del viatger i la nostra predicció
submission <- data.frame(seq(892,1309),solution$Survived_pred)
# Assignem els noms correctes a les columnes
colnames(submission) <- c("PassengerId", "Survived")
# Guardem el dataframe en un fitxer
write.csv(submission, '../data/submission.csv', row.names = FALSE)
```

# 7. Recursos

* Calvo, M.; Subirats, L.; Pérez, D. (2019). *Introducción a la limpieza y análisis de los datos*. Editorial UOC.
* Squire, Megan (2015). *Clean Data*. Packt Publishing Ltd.
* Dalgaard, Peter (2008). *Introductory statistics with R*. Springer Science & Business Media.
* *Data visualization catalogue*. https://datavizcatalogue.com.

# 8. Taula de contribucions al treball

* **Recerca prèvia:** Jesús Marí, Víctor Boix
* **Redacció de les respostes:** Jesús Marí, Víctor Boix
* **Desenvolupament del codi:** Jesús Marí, Víctor Boix

