---
lang: ca-ES
title: "Pràctica 2: Neteja i validació de dades"
subtitle: "Tipologia i cicle de vida de les dades"
author: "Jesús Marí i Víctor Boix"
date: "Data de presentació: 11/06/2019"
output: 
  pdf_document:
    toc: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r include=FALSE}
# Càrrega de paquets
library(colorspace)
library(grid)
library(data.table)
library(VIM)
library(ggplot2)
library(plyr)
library(nortest)
library(ROCR)
library(pROC)
library(gmodels)
```

------

# 1. Descripció del dataset

El dataset utilitzat en aquesta pràctica s'ha obtingut de la pàgina web de *Kaggle*  (https://www.kaggle.com/c/titanic) i conté les dades dels passatgers del Titanic durant el desastre del 1912. L'objectiu d'aquest conjunt de dades és realitzar una predicció sobre la supervivència d'alguns passatgers a partir de les seves característiques. Per tant, es tracta d'un problema de classificació d'aprenentatge supervisat, on cal construir un model capaç de determinar el valor de l'atribut *Survived* (variable objectiu o dependent) a partir de la resta d'atributs (variables independents). 

Les conjunt de dades està format per dos fitxers CSV:

* *Titanic_train.csv*. Conjunt d'entrenament que servirà per entrenar el model, per tant, conté l'atribut objectiu o classe *Survived*. Està format per 891 registres i 12 atributs.
* *Titanic_test.csv*. Conjunt de prova, conté els registres sobre els que cal realitzar la predicció. Està format per 418 registres i 11 atributs.

La informació que contenen els atributs és la següent:

* *PassengerId*. Identificador únic del viatger al dataset (nombre enter).
* *Survived*. Atribut que indica si el passatger va sobreviure a la catàstrofe (1: va sobreviure, 0: va morir). Només disponible al conjunt *train*.
* *Pclass*. Indica la classe en què viatjava el passatger (1: primera classe, 2: segona classe, 3: tercera classe).
* *Name*. Nom complet del viatger (cadena de text).
* *Sex*. Sexe del viatger (male: home, female: dona).
* *Age*. Edat del viatger en anys (nombre real).
* *SibSp*. Nombre de germans, germanes o marit/muller a bord del vaixell (nombre enter).
* *Parch*. Nombre de pares o fills a bord del vaixell (nombre enter).
* *Ticket*. Nombre del tiquet (cadena de text).
* *Fare*. Import pagat pel bitllet (nombre real).
* *Cabin*. Cabina on s'allotjava el passatger (cadena de text).
* *Embarked*. Port d'embarcament del viatger (C: Cherbourg, Q: Queenstown, S: Southampton).

# 2. Integració i selecció de les dades

Per tal de realitzar els processos de neteja i anàlisi de les dades carregarem els dos fitxers en
dos dataframes que anomenarem *train* i *test*. Totes les operacions de neteja les realitzarem sobre els dos dataframes.

```{r}
# Càrrega dels fitxers de dades
train <- read.csv('../data/Titanic_train.csv')
test <- read.csv('../data/Titanic_test.csv')
```

L'atribut *PassengerId* és un identificador numèric dels registres del dataframe que no ens aporta cap informació sobre els passatgers, per tant, l'eliminarem, ja que per identificar els registres ja disposem de l'índex.

```{r}
# Eliminem l'atribut PassengerId a train i test
train <- train[,-1]
test <- test[,-1]
```

La resta d'atributs els mantindrem perquè ens donen informació sobre el viatger i poden resultar útils per al model. Podem fer una visualització dels primers registres amb la funció *head()*.

```{r}
# Primers registres del dataframe train
head(train)
```

# 3. Neteja de les dades

Comencem examinant el dataframe amb la funció *str()*, que ens mostra el tipus de dada i els valors dels primers registres per a cada atribut.

```{r}
# Examinem el conjunt train
str(train)
```

```{r}
# Examinem el conjunt test
str(test)
```

L'atribut *Name* és de tipus factor, però té tant nivells com registres, per tant el convertirem a character.

```{r}
# Conversió de Name a character
train[,'Name'] <- as.character(train[,'Name'])
test[,'Name'] <- as.character(test[,'Name'])
```

La variable *Survived* és l'atribut classe i, per tant, és de tipus categòric. En aquest cas farem la conversió a factor.

```{r}
# Conversió de Survived a factor
train[,"Survived"] <- as.factor(train[,"Survived"])
```

Els tipus de dada per a cada atribut són:

* *Factor*: Sex, Ticket, Cabin, Embarked, Survived
* *int*: Pclass, SibSp, Parch
* *num*: Age, Fare
* *chr*: Name

Abans d'analitzar els elements buit i extrems pot resultar útil mostrar un resum de les dades amb la funció *summary()*.

```{r}
# Resum de les dades train
summary(rbind(train[-1],test))
```


## 3.1. Elements buits

Per començar examinem els elements buits a les columnes dels dos conjunts de dades. Podem veure que tenim molts valors NA a la columna *Age* dels dos dataframes i un a la columna *Fare* del conjunt de test. 

```{r}
# Nombre de valors NA per atribut
sapply(train, function(x) sum(is.na(x)))
sapply(test, function(x) sum(is.na(x)))
```

A més, els atributs *Cabin* i *Embarked* també contenen valors buits.

```{r}
# Nombre de valors buits per atribut
sapply(train, function(x) nrow(train[x=='',]))
sapply(test, function(x) nrow(test[x=='',]))
```

**Fare**

Per imputar el valor buit del preu del bitllet (*Fare*) podem utilitzar la informació de la classe del viatger (*Pclass*), ja que és lògic pensar que els bitllets de millor classe seran més cars. Això ho podem confirmar mostrant la mitjana de *Fare* per a cada valor de *Pclass*.

```{r}
# Mitjana de Fare per cada valor de Pclass als conjunts train i test conjuntament
aggregate(Fare~Pclass, data=rbind(train[,-1],test), mean)
```

Com veiem, hi ha una diferència significativa entre la mitjana del preu de bitllet per a cada classe. Utilitzarem aquesta circumstància per imputar el valor NA de *Fare* amb la mitjana de valors per als viatgers de la mateixa classe.

```{r}
# Imputem el valor NA de Fare amb la mitjana de valors de la mateixa classe
test[is.na(test$Fare),'Fare'] <- aggregate(Fare~Pclass, data=rbind(train[,-1],test),
                                           mean)[test[is.na(test$Fare),'Pclass'],'Fare']
```

**Cabin**

En el cas de l'atribut *Cabin*, substituirem els valors buits pel marcador 'NO'.

```{r}
levels(train$Cabin)[levels(train$Cabin)==''] <- 'NO'
levels(test$Cabin)[levels(test$Cabin)==''] <- 'NO'
```

**Embarked**

Per imputar els valors buits del port d'embarcament (*Embarked*) podem aprofitar la informació del bitllet. Si consultem les dades dels viatgers que tenen un valor buit a *Embarked* veiem que tenen el mateix número de bitllet.

```{r}
# Ticket dels viatgers amb valor buit a Embarked
train[train$Embarked=='',c("Embarked", "Ticket")]
```

Si ampliem la cerca i mostrem el valor d'*Embarked* per a tots els viatgers amb un número de bitllet semblant (113XXX) veiem que la majoria han pujat a Southampton ('S'). Per tant assignarem aquest valor als dos valors buits d'*Embarked*.

```{r}
# Viatgers amb un número de ticket semblant a l'anterior (113XXX) agrupats pel valor d'Embarked
 summary(train[grep("113.*",train$Ticket),"Embarked"])

# Assignem el valor 'S' als valors buits d'Embarked
levels(train$Embarked) <- c("S", "C", "Q", "S")
```

**Age**

Finalment, per imputar el valor buit de l'edat (*Age*) farem servir el mètode basat en els k-veïns més propers (KNN). El que fa l'algorisme knn-imputation és identificar les k-observacions més properes i assignar la mitjana ponderada a l'atribut amb valor NA. En el nostre cas utilitzarem k=3 i tindrem en compte tots els atributs excepte *Name*.

```{r}
# Imputació de valors amb VIM
train$Age <- kNN(train[,-3], k=3)$Age 
test$Age <- kNN(test[,-2], k=3)$Age 
```

Per acabar, comprovem que ja no hi ha cap valor NA o buit.

```{r}
# Nombre de valors NA per atribut
sapply(train, function(x) sum(is.na(x)))
sapply(test, function(x) sum(is.na(x)))

# Nombre de valors buits per atribut
sapply(train, function(x) nrow(train[x=='',]))
sapply(test, function(x) nrow(test[x=='',]))
```

## 3.2. Valors extrems

Els valors extrems o *outliers* són aquells valors que es troben tan allunyats de la resta de valors que ens poden fer pensar que són erronis o tenen un origen diferent. Generalment es consideren *outliers* els valors que estan a més de 3 desviacions estàndards de la mitjana de la població. A continuació estudiarem els valors extrems per als atributs de tipus numèric, tant enters com reals.

**Age**

Si representem el diagrama de caixa de l'atribut *Age* veiem que la majoria de passatgers se situen entre els 20 i els 40 anys, però també apareixen alguns punts aïllats per sobre dels 60 anys.

```{r}
# Diagrama de caixa de l'atribut Age
A.Age <- c(train$Age,test$Age)
boxplot(A.Age, horizontal = TRUE)
```

Si mostrem els valors extrems per a aquest atribut obtenim molts valors entre 60 i 80.

```{r}
# Possibles outliers a l'atribut Age
boxplot.stats(A.Age)$out
```

Si calculem els valors que es troben per sobre de 3 desviacions estàndard el nombre d'*outliers* disminueix a només 3.

```{r}
# Edats superiors a 3 desviacions estàndard per sobre de la mitjana
A.Age[A.Age > (mean(A.Age) + 3 * sd(A.Age))]

# Rang total de l'atribut Age
range(A.Age)
```

Tot i que hem detectat 3 possibles outliers, tots els passatgers se situen entre els 0 i els 80 anys, que són edats perfectament possibles i per tant mantindrem tots els registres sense cap modificació.


**SibSp**

L'atribut *SibSp* ens indica el nombre de germans o marit/muller de cada passatger. Si mostrem la distribució de valors en una diagrama de caixa veiem que la majoria de valors se situen entre 0 i 1.

```{r}
# Diagrama de caixa de l'atribut SibSp
A.SibSp <- c(train$SibSp, test$SibSp)
boxplot(A.SibSp, horizontal = TRUE)
```

Repetint les anàlisis anteriors veiem que la funció *boxplot* detecta com a extrems els valors superiors a 2, si calculem els valors superiors a 3 desviacions estàndard trobem els valors superiors a 3, mentre que el valor més alt de l'atribut és de 8. Tots aquests valors són perfectament possibles com a nombre de fills i per tant també els mantidrem.

```{r}
# Possibles outliers a l'atribut SibSp
boxplot.stats(A.SibSp)$out

# Valors per sobre de 3 SD
A.SibSp[A.SibSp > (mean(A.SibSp) + 3 * sd(A.SibSp))]

# Rang total de l'atribut
range(A.SibSp)
```

**Parch**

L'atribut *Parch* indica el nombre de pares o fills al vaixell per a cada passatger. Si repetim els càlculs obtenim un resultat molt semblant a l'anterior. En aquest cas, la majoria de registres tenen un valor de 0, això fa que la mitjana sigui molt baixa i la resta de valors apareguin com a outliers. Malgrat tot, els rang de l'atribut se situa entre 0 i 9 fills, que són valors possibles i que encaixen amb els resultats de *SibSp*, per tant també els mantindrem.

```{r}
# Diagrama de caixa de l'atribut Parch
A.Parch <- c(train$Parch, test$Parch)
boxplot(A.Parch, horizontal = TRUE)
```

```{r}
# Possibles outliers a l'atribut Parch
boxplot.stats(A.Parch)$out

# Valors per sobre de 3 SD
A.Parch[A.Parch > (mean(A.Parch) + 3 * sd(A.Parch))]

# Rang total de l'atribut
range(A.Parch)
```

**Fare**

Per acabar estudiarem els valors extrem de l'atribut *Fare*, que indica el preu del bitllet de cada passatger. En aquest cas veiem que la majoria de bitllets se situen per sota de 50, tenim molts possibles *outliers* per sobre de 80 i un valor màxim superior als 500.

```{r}
# Diagrama de caixa de l'atribut Fare
A.Fare <- c(train$Fare, test$Fare)
boxplot(A.Fare, horizontal = TRUE)
```

```{r}
# Possibles outliers a l'atribut Fare
boxplot.stats(A.Fare)$out

# Valors per sobre de 3 SD
A.Fare[A.Fare > (mean(A.Fare) + 3 * sd(A.Fare))]

# Rang total de l'atribut
range(A.Fare)
```

Com en els casos anteriors, per a aquest atribut també hem decidit mantenir tots els valors.


## 3.3. Conversió de dades

A continuació transformarem alguns atributs per tal de reduir-ne el nombre de categories o obtenir-ne informació que pugui resultat interessant per a la fase d'anàlisi.

**Name**

A l'atribut *Name* n'extraurem el títol de tractament, ja que indica l'estatus del viatger i pot influir en la seva supervivencia.

```{r}
# Extraiem el títol de l'atribut Name
train$Title <- sub(".*\\s([A-Za-z]+)\\..*", "\\1", train$Name)
test$Title <- sub(".*\\s([A-Za-z]+)\\..*", "\\1", test$Name)

# Nombre de registres per categoria de Title
table(c(train$Title, test$Title))
```

A continuació, com que el nombre de categories és força gran i algunes tenen molt pocs registres, unirem els títols poc freqüents ens una mateixa categoria 'other'. Per acabar, convertim l'atribut a tipus factor.

```{r}
# Marquem com a 'other' els títols menys freqüents
others <- c("Capt","Countess","Don","Dona","Jonkheer","L","Lady","Mme","Sir",
            "Major","Mlle","Ms","Col","Dr","Rev")
train[train$Title %in% others, 'Title'] = 'other'
test[test$Title %in% others, 'Title'] = 'other'

# Convertim Title a factor
train$Title <- as.factor(train$Title)
test$Title <- as.factor(test$Title)
```

**Cabin**

L'atribut cabina conté més de 100 nivells. Una manera de reduir-los pot ser eliminar els números i conservar únicament la lletra, ja que segurament indica el tipus de cabina o la zona on s'allotjaven els passatgers i pot resultar significativa.

```{r}
# Extraiem la lletra de l'atribut Cabin
levels(train$Cabin)[-1] <- sub("([A-T]).*","\\1", levels(train$Cabin)[-1])
levels(test$Cabin)[-1] <- sub("([A-T]).*","\\1", levels(test$Cabin)[-1])

# Freqüència de supervivents per cabina
table(train[,c("Survived","Cabin")])
```

Com veiem, les cabines A, F, G i T tenen molt pocs passatgers i un percentatge de supervivents força semblant. Per evitar tenir cabines amb pocs registres i millorar l'eficàcia de les anàlisis unirem aquestes cabines en una mateixa categoria que anomenarem X.

```{r}
# Reanomenem a X les cabines A, F, G i T
levels(train$Cabin) <- c("NO", "X", "B", "C", "D", "E", "X", "X", "X")
levels(test$Cabin) <- c("NO", "X", "B", "C", "D", "E", "X", "X", "X")
```

**Ticket**

Finalment, tot i que l'atribut *Ticket* també conté molts nivells i sembla poc útil, podem provar d'extreure'n alguna informació interessant. A continuació mostrem les dades d'alguns passatgers que comparteixen el valor de *Ticket*.

```{r}
# Valors més freqüents de Ticket
sort(table(train$Ticket), decreasing = TRUE)[c(1:5)]

# Passatgers amb el Ticket més freqüent
train[train$Ticket=='1601',]
```

Com veiem, els passatgers amb un mateix valor per a *Ticket* també comparteixen moltes característiques, perquè segurament formaven una família o viatjaven junts. Això ho aprofitarem per calcular la mida del grup de persones que viatjaven conjuntament i crear l'atribut *Group*.

```{r}
# Creem una taula de freqüències per als tickets
tickets <- as.data.frame(table(rbind(train["Ticket"],test["Ticket"])))
colnames(tickets) <- c("Ticket","Group")

# Assignem el valor de la freqüència a un nou atribut "Group"
train <- join(train, tickets, by="Ticket")
test <- join(test, tickets, by="Ticket")
```

**Fare**

Finalment, com que el preu del bitllet sembla ser el mateix per a cada ticket, és a dir, sembla tractar-se de l'import per a tot el grup, dividirem l'import del passatge (*Fare*) per les dimensions del grup (*Group*) per tal d'obtenir el preu individual del bitllet.

```{r}
# Càlcul del preu individual del bitllet
train$Fare <- train$Fare / train$Group 
test$Fare <- test$Fare / test$Group
```

Per acabar, eliminem els atributs *Name* i *Ticket* per evitar la redundància de dades, ja que els hem utilitzat per generar els atributs derivats *Title* i *Group*.

```{r}
# Eliminem l'atribut Name i Ticket
train <- train[,-c(3,8)]
test <- test[,-c(2,7)]
```


## 3.4. Exportació de dades

Una vegada hem netejat les dades les exportarem en un nou fitxer.

```{r}
# Exportació dels conjunt train i test nets
write.csv(train, '../data/Titanic_train_clean.csv')
write.csv(test, '../data/Titanic_test_clean.csv')
```

# 4. Anàlisi de dades

## 4.1. Selecció de dades

La fase d'anàlisi s'enfocarà en estudiar les dades des de diferents punts de vista i intentant respondre diferents preguntes:

1. Com és la distribució de valors per a les variables numèriques contínues? La mitjana de valors és significativament diferent per als supervivents i no supervivents?
2. Hi ha correlacions entre variables numèriques que permetin prescindir d'algun atribut?
3. La probabilitat de sobreviure és significativament diferent entre les diferents categories?
4. Quina és la probabilitat de sobreviure per als passatgers del conjunt de test?

La primera pregunta estudia la distribució de les variables numèriques contínues (*Age* i *Fare*). Començarem estudiant si els seus valors segueixen una distribució normal, a continuació compararem la variància en funció del valors de la classe (*Survived*) i, finalment, aprofitarem aquest resultat per comparar la mitjana de valors en funció del valor de la classe (*Survived*). Això ens permetrà saber si la mitjana d'edat i del preu del bitllet són significativament diferents entre els supervivents i els no supervivents.

Per a respondre la segona pregunta estudiarem la correlació entre les variables quantitatives (*Pclass*, *Age*, *SibSp*, *Parch*, *Fare* i *Group*). En principi es tracta de les variables independents del conjunt de dades, per aquest motiu, si detectem alguna dependència important significarà que hi ha redundància en les dades i pot ser necessari eliminar alguna columna. Per fer aquesta anàlisi treballarem amb els dos conjunts de dades: *train* i *test*.

La tercera pregunta se centra en les variables qualitatives (*Sex*, *Cabin*, *Embarked* i *Title*) on avaluarem si hi ha diferències significatives en el percentatge de supervivents entre els diferents grups definits per aquestes variables. Per fer aquesta anàlisi utilitzarem el test de $\chi^2$ amb la funció *chisq.test*, també sobre les dades de *train*.

Finalment, la darrera pregunta és un problema de classificació. Treballarem amb el conjunt *train* per crear un model de regressió logística a partir de totes les variables, tant les numèriques com les categòriques, i  l'utilitzarem per efectuar prediccions sobre el conjunt de *test*.

```{r}
# Variables numèriques
var_num <- c("Pclass","Age","SibSp","Parch","Fare","Group")

# Variables categòriques
var_cat <- c("Sex","Cabin","Embarked","Title")
```

Abans de fer totes aquestes anàlisis comprovarem la normalitat i homocedasticitat de les variables quantitatives.

## 4.2. Anàlisi de la distribució de variables contínues Age i Fare

Per fer les anàlisis de normalitat i homogeneïtat de la variància ens centrarem en els atributs de tipus *numeric*, que són *Age* i *Fare*. En primer lloc unirem els dos conjunts de dades en un mateix dataframe per facilitar-ne l'estudi.

```{r}
# Unim les dades en un dataframe
test_and_train <- rbind(train[c("Age","Fare")],test[c("Age","Fare")])
```

### 4.2.1 Normalitat

**Age**

Començarem analitzant la normalitat de la distribució de l'atribut *Age* de manera gràfica, representant les dades en un histograma i utilitzant la gràfica Q-Q.

```{r}
# Representem les dades en un histograma
ggplot(data = test_and_train, aes(x = Age)) +
  geom_histogram(aes(y = ..density.., fill = ..count..), binwidth = 3) +
  scale_fill_gradient(low = "#DCDCDC", high = "#7C7C7C") +
  stat_function(fun = dnorm, colour = "firebrick",
                args = list(mean = mean(test_and_train$Age),
                            sd = sd(test_and_train$Age))) +
  ggtitle("Histograma + curva normal") +
  theme_bw()
```

Tot i que la majoria de franges d'edat s'acosten a una distribució normal, l'interval aproximat entre 18 i 25 anys és molt més freqüent que la resta i s'allunya molt d'aquesta distribució. Com veiem a continuació, la gràfica Q-Q segueix la línia de normalitat a la regió central però s'allunya als extrems.

```{r}
qqnorm(test_and_train$Age, pch = 19, col = "gray50")
qqline(test_and_train$Age)
```

Per tal d'avaluar la normalitat de la distribució de manera numèrica utilitzarem el contrast d'hipòtesis. En primer lloc farem el test de Shapiro-Wilk. Prenent com a hipòtesi nul·la que la distribució de valors d'*Age* és normal i fixant un nivell de significació del 5%, veiem com el càlcul del p-valor és molt inferior al nivell de significació i ens veiem obligats a rebutjar la hipòtesi nul·la; és a dir, no podem afirmar que la distribució d'*Age* sigui normal.

```{r}
# Test de normalitat de Shapiro-Wilk
shapiro.test(test_and_train$Age)
```

Com que es tracta d'una mostra relativament gran (|T| > 50), verificarem els resultats amb el test d'Anderson-Darling. Els resultats també ens diuen que no podem considerar que la distribució d'edats segueixi una corba normal.

```{r}
# Test de normalitat d'Anderson-Darling
ad.test(test_and_train$Age)
```

**Fare**

A continuació repetim les gràfiques i els càlculs per avaluar la normalitat de l'atribut *Fare*.

```{r}
# Representem les dades en un histograma
ggplot(data = test_and_train, aes(x = Fare)) +
  geom_histogram(aes(y = ..density.., fill = ..count..), binwidth = 3) +
  scale_fill_gradient(low = "#DCDCDC", high = "#7C7C7C") +
  stat_function(fun = dnorm, colour = "firebrick",
                args = list(mean = mean(test_and_train$Fare),
                            sd = sd(test_and_train$Fare))) +
  ggtitle("Histograma + curva normal") +
  theme_bw()
```


```{r}
qqnorm(test_and_train$Fare, pch = 19, col = "gray50")
qqline(test_and_train$Fare)
```

A nivell gràfic, els valors de *Fare* tampoc semblen seguir una distribució normal. Això ho confirmem amb els tests de Shapiro-Wilk i d'Anderson-Darling.

```{r}
# Test de normalitat de Shapiro-Wilk
shapiro.test(test_and_train$Fare)
```

```{r}
library(nortest)
# Test de normalitat d'Anderson-Darling
ad.test(test_and_train$Fare)
```

En tots dos casos el càlcul del p-valor resulta molt inferior al nivell de significació i, per tant, no podem afirmar que els valors de l'atribut *Fare* segueixin una distribució normal.


### 4.2.2. Homoscedasticitat

A continuació estudiarem si la variància de les variables numèriques *Age* i *Fare* és constant als grups de les persones que sobreviuen respecte a les que no ho fan. Com que cap de les dues de les variables té una distribució normal utiltizarem el test Fligner-Killeen. En aquest test la hipòtesi nul·la contempla que les variàncies entre els grups són iguals.

**Age**

```{r}
a <- train[train$Survived == 0,"Age"]
b <- train[train$Survived == 1,"Age"]
fligner.test(x = list(a,b))
```

Com el p-valor resultat és més gran que 0.05 no hi ha una justificació per rebutjar la hipòtesi nul·la. Això ens indica que la variància de l'edat és similar en ambdós grups.


**Fare**

```{r}
a <- train[train$Survived == 0,"Fare"]
b <- train[train$Survived == 1,"Fare"]
fligner.test(x = list(a,b))
```

Com el p-valor resultat és pràcticament 0, podem rebutjar la hipòtesi nul·la. Això ens indica que la variància de la variable *Fare* és significativament diferent en ambdós grups. Aquest resultat el podem comprovar gràficament mostrant la distribució de valors per a les dues classes en un diagrama de caixa.

```{r}
# Diagrama de caixa de Fare per a les classes de Survived
ggplot(data = train, aes(x = Survived, y = Fare, colour = train$Survived)) +
  geom_boxplot() +
  geom_point() +
  theme_bw() +
  theme(legend.position = "none")
```

### 4.2.3. Comparació de les mitjanes d'*Age* i *Fare*

Les variables *Age* i *Fare* presenten una important desviació respecte de la normal i no és possible la seva transformació mitjançant les tècniques habituals (log, sqrt...) pel que emprarem el test no paramètric de Kruskal-Wallis per analitzar la diferència de les seves mitjanes.
En aquest test la hipòtesi nul·la contempla que les distribucions entre els grups són iguals.

```{r}
# Test de Kruskal-Wallis aplicat a Age respecte Survived
kruskal.test(Age  ~ Survived, data = train ) 

# Test de Kruskal-Wallis aplicat a Fare respecte Survived
kruskal.test(Fare  ~ Survived, data = train ) 
```

Com podem veure al resultat la distribuició d'edat dels que sobreviuen no és significativament diferent entre els que hi sobreviuen i els que no, al contrari que a la variable *Fare*, si és diferent.

## 4.3. Anàlisi de correlació

En aquest apartat ens preguntem si hi ha correlacions entre variables numèriques que permetin prescindir d'algun atribut. Per analitzar les possibles dependències generarem una matriu de correlacions entre totes les variables quantitatives dels conjunts de dades *train* i *test* conjuntament; a més, utilitzarem la correlació de *Spearman*, que no suposa cap tipus de distribució entre les dades, perquè com hem vist hi ha variables numèriques que no segueixen una distribució normal.

```{r}
# Correlació entre variables numèriques
cor(rbind(train[var_num], test[var_num]), method="spearman")
```

Com era d'esperar, hi ha una forta correlació entre els atributs *Fare* i *Pclass*; el coeficient de *Spearman* és de -0.83, força proper a -1, que vol dir que a classes més altes (valors més petits) augmenta el preu del bitllet i a l'inversa. A més, també s'aprecia una correlació positiva entre *Group-Parch* (0.64) i *Group-SibSp* (0.61) perquè tots aquests atributs informen de la mida de la família o grup de gent que viatjava conjuntament. Altres correlacions menys importants són *Age-Pclass* (-0,41), classes més altes (valors petits de Pclass) tenen edats més grans, i *SibSp-Parch* (0.43).

## 4.4. Contrast d'hipòtesis

A la tercera pregunta ens qüestionem si les diferents categories de les variables qualitatives (*Sex*, *Cabin*, *Embarked* i *Title*) influeixen en la probabilitat de sobreviure. Atès que la variable *Survived* també és qualitativa, emprarem el test *Chi quadrat* amb la hipotesi nul·la que diu que les variables examinades no són independents. Primer calcularem les freqüències de *Survived* per a cada categoria i després aplicarem la funció *chisq.test*.

```{r}
# Test chi quadrat per a totes les variables qualitatives
for (col in var_cat){
  # Creem una taula de freqüències
  taula = table(train[, c("Survived", col)])
  print(taula)
  # Apliquem el test
  print(chisq.test(taula))
}
```

A L'execució podem veure com el p-valor és inferior al 0.05 en tots els casos, per tant, rebutgem la hipòtesi nul·la. Això vol dir que podem afirmar que hi ha diferències significatives entre el nombre de supervivents per a les diferents categories de *Sex*, *Cabin*, *Embarked* i *Title*.

## 4.5. Regressió logística

Finalment, calcularem la probabilitat de supervivència per als passatgers del conjunt *test*. En el nostre cas, com que la variable a predir (dependent) és dicotòmica, utilitzarem una regressió logística.

### 4.5.1. Creació del model

Per generar el model de regressió logística utilitzarem la funció *regLog* amb totes les variables disponibles, tant les categòriques com les numèriques. Les variables numèriques no requereixen cap tipus de transformació, però les categòriques s'hauran de binaritzar, és a dir, haurem de crear un atribut de tipus binari per a cada categoria; malgrat tot, la funció *regLog* ja realitza aquesta transformació i per tant no serà necessari modificar cap atribut. 

```{r}
# Generem el model de regressió logística
regLog <- glm(Survived ~ Pclass + Age + SibSp + Parch + Fare + Group + Sex + Cabin + Embarked + Title,
              data = train, family = binomial(link="logit"))
regLog$coefficients
```


### 4.5.2. Avaluació del model

A continuació cerquem el millor llindar per a prendre la decisió de quan sobreviu un individu donada la seva probabilitat.  

```{r}
# Calculem la probabilitat de supervivència dels passatgers del conjunt train
prob_Survived <- predict(regLog, train, type="response")
y_train <- cbind(train, prob_Survived)
head(y_train,5)
```

Per a obtenir el llindar més adequat de probabilitat observem la corba ROC. 

```{R}
# Corba ROC del conjunt train
plot.roc(y_train$Survived, y_train$prob_Survived,  
         main="Confidence interval of a threshold",
         percent=TRUE,  ci=TRUE, of="thresholds",
         thresholds="best", 
         print.thres="best")
```

Assignem el llindar a 0.5 obtingut a la corba.

```{r}
# Assignem com supervivents les probabilitats superiors al 50%
y_train$Survived_pred <- ifelse(y_train$prob_Survived>0.5, 1,0)
# Convertim les prediccions atipus factor
y_train$Survived_pred <- as.factor(y_train$Survived_pred)
# Mostrem la matriu de confusió
gmodels::CrossTable(y_train$Survived,y_train$Survived_pred)
```

### 4.5.3. Predicció del conjunt test

Els coeficients obtinguts són els paràmetres de la funció que modelitza la probabilitat de supervivència per a cada atribut. A partir d'aquests paràmetres podem fer una predicció de la probabilitat de supervivència del conjunt *test* amb la funció *predict*.

```{r}
# Calculem la probabilitat de supervivència dels passatgers del conjunt test
prob_Survived <- predict(regLog, test, type="response")
# Afegim la predicció al conjunt de dades
solution <- cbind(test, prob_Survived)
# Assignem com a supervivents els passatgers amb probabilitats superiors al 50%
solution$Survived_pred <- ifelse(solution$prob_Survived>0.5, 1,0)
# Convertim la predicció a tipus factor
solution$Survived_pred<-as.factor(solution$Survived_pred)
# Mostrem els resultats per als primers registres
head(solution,5)
```


# 5. Representació de dades

A partir dels coeficients normalitzats de la regressió logística obtindrem les variables més significatives. Amb la funció *beta* normalitzem els coeficients i podem veure que Sex, Title, Cabin, Group, Fare i Embarked, són les més significatives. 

```{r}
library("reghelper")
beta(regLog)
```
Obtenim una visió general de tot el dataframe de la solució del problema amb un gràfic de conjunts paral·lels. 
El diagrama mostra clarament que hi ha menys homes que sobreviuen, probablement perquè els primers a evacuar el vaixell foren Dones i nins.  
També podem veure que un gruix important dels que no sobreviuen no tenen assignat una cabina, probablement viatjaven a les bodegues del vaixell. 

```{r}
library(ggforce)
names(solution)[names(solution) == "Sex"] <- "C_Sex"
names(solution)[names(solution) == "Title"] <- "D_Title"
names(solution)[names(solution) == "Embarked"] <- "B_Embarked"
names(solution)[names(solution) == "Cabin"] <- "A_Cab"
names(solution)[names(solution) == "Survived_pred"] <- "E_Surv"

data <- reshape2::melt(solution)
data <- gather_set_data(data, c("C_Sex", "D_Title", "B_Embarked", "A_Cab" , "E_Surv"))

ggplot(data, aes(x, id = id, split = y, value = value)) +
  geom_parallel_sets(aes(fill = E_Surv), alpha = 0.3, axis.width = 0.1) +
  geom_parallel_sets_axes(axis.width = 0.2) +
  geom_parallel_sets_labels(colour = 'white')
```

**Piràmide segons *Fare*
Analitzem el comportament depenent de *Fare. Amb una piràmide, representem les persones que hi sobreviuen a l'esquerra del 0 i els que no ho fan, a la dreta. Al gràfic veiem clarament que el grup de (0,10] és el més nombrós, però no és fàcil veure que percentualment sigui el que té la probabilitat més alta de no sobreviure, de fet, *Fare* és de les variables significatives amb menys pes, en canvi, de nou es veu que el percentatge de dones que hi sobreviuen és més alt que el dels homes, llevat del grup que va pagar (30,40]

```{R}
library(magrittr)

piramid_solution <- solution[, c("Fare","E_Surv","C_Sex")]
piramid_solution$Fare <- cut(piramid_solution$Fare, seq(-0,100,by=10))
piramid_solution <- count(piramid_solution, c("Fare","C_Sex","E_Surv"))


ggplot(data = piramid_solution, aes(x = Fare, y = freq, fill = C_Sex )) +
  #bars for all but 2100
  geom_bar(data = subset(piramid_solution, E_Surv == 0),
           stat = "identity",
           position = "identity") +
  geom_bar(data = subset(piramid_solution, E_Surv == 1) ,
           stat = "identity",
           position = "identity",
           mapping = aes(y = -freq)) +
        coord_flip() + 
  scale_y_continuous(labels = abs)
```

# 6. Resolució del problema

# 7. Recursos

